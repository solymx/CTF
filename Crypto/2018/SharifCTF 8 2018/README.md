# SharifCTF 8 2018 - Notes

## DES
> Description:
> 
> See known_plaintexts.txt:
> There is a single unknown DES key K.
> All plain texts are encrypted under K, resulting in the corresponding cipher text.
> Can you find K?
> flag is SharifCTF{K},
> where K is a 64-bit hexadecimal value, without the 0x prefix. (K includes the parity bits.)

打開題目給的檔案，一個個看，可以看到有
```
ef17ae3946ebae4c -> f084cae61e607b05
f084cae61e607b05 -> ef17ae3946ebae4c
```

可以知道 E(E(M)) = M ，也就是加密兩次 = 本來的 M ，從這邊可以知道他用的是 Weak key

這樣的 weak key 有四把
```
\x01\x01\x01\x01\x01\x01\x01\x01
\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE
\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1
\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E
``` 

就一把把試試看

可以用個簡單小程式看一下
```
#!/usr/bin/env python
from Crypto.Cipher import DES

m = '89bc8acb348c1ecc'
c = '9e31e5f5a8cef654'
key = ['\x01\x01\x01\x01\x01\x01\x01\x01',
'\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE',
'\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1',
'\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E']
for k in key:
	des_func = DES.new(k, DES.MODE_ECB)
	if m == des_func.decrypt(c.decode('hex')).encode('hex'):
		print "key: ",k.encode('hex')
		break
```

## OSS Signature - Easy

參考:
[1](https://github.com/VoidHack/write-ups/tree/master/SharifCTF%208/crypto/OSS)
[2](https://github.com/abeaumont/ctfs/tree/master/sharif-2018/oss-service-easy)


打開的題目頁面
![image](../img/c88KHCg.png)

更多描述可以參考 OSS_Signature.pdf ，確認 signature 的 python code 可以看 verify.py

根據 OSS_Signature.pdf 可以知道我們現在有的資訊是
```
x^2 + k*y^2 = m (mod n)
x'^2 + k*y'^2 = m' (mod n)

且已知 x, y, x', y', m, m', n, k

然後目標是獲取 x'' 和 y'' 使其滿足:
x''^2 + k^y''^2 = m * m' (mod n)
```

這題直接參照 [Pollard’s Solution of OSS Equations](https://github.com/VoidHack/write-ups/blob/master/SharifCTF%208/crypto/OSS/pdfs/Pollard.pdf)

看該 pdf 的72 頁，照公式來即可

簡單寫一個 python
```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-
def verify(public, m, sigma):
	n = public[0]
	k = public[1]
	x = sigma[0]
	y = sigma[1]
	return (x**2 + k*y**2 - m) % n == 0

n = 25002746673023214443255611415004163622813167852050923858455529030203886977840435991633024079845736335150468784530123301961464111492802951263984843039164056430832125163123383805713707250515254073169424707009359341759806003392594138294458167902830484152672696274313541002376076183872266230285338817553110422277895445022423407252341583782719664554600485831653496762352727294140410862007839241034826246409937408317586016100320118339304493568308875379717324497727750190898854014202895798781129867240530387323567711557244359201718574163779140769622702892937997637399632813759046725913242153879394145202439145824342609530733
k = 23362339402422379817772327315061502761593494363846640180372992347552364432329220756030231112957778618810078666762974577247225709089334422591782884749584385632941885055318288495081651413041625183693553233252837243762098828064089396976796784829512691690456121528386778151445275489241471824325584238311939845541912403985291213425145453729490975518843542282785674261698826757381575038415836220944506894913500128933084291790059465445840440895339431303999096861113452752000364738364437105439080665770770436241486563132717407593776498512206813885900089036806429313524876146779148195897063040217695170237733473446418668779916
public = (n, k)

m1 = 53
x1 = 4996965626677818470899497036192572928953383468049981492215052947486968576469160069531045847406602867300998349717580001316746485225762698993261684213353602996748343182092335509307573088247624968954427896794412611830427704686799860673116498727830792282242951843221232059541413610254765610041160440513577441311377402794483664718403091720812660740195547201741143700725549004496527350569773313437105547331241515716525604301492268657755586190938586265947367522921813698603847151625881131098032431190975920711377012137155839366204869205993663573232084527465728306732531071378794321276304228712618173043121942149396615492478
y1 = 9339264669983291900327820828270098016379861097267077744514708712834641173057650202534710250765922313741944462789942785478170212231431727070626211785081581216011869498431598197306917945956602966039228580868647572114697339953682091890878192717124657001319847969571764996539075871196135114129827099959218903704028739118783540539731484487013859564619154565781303034838767726419327010072827695144834838584650689215227715966068273968350448794571951839296494120274908108873597642627135960002648616376004036368059928510282972523844522428329769439534207771320850592847756802766651250916352633401119949553102145237888877557923


m2 = 97
x2 = 11753106345254288737361588513147237177750400928549963607707054166942720184532870164663313254526876864287114091403255773460126703446364096215167350117522512230363460796882926739640334786094541017927436061884032962475855870728763342865282312282570446248990619133180907228013976489639609306879272823217110322646001510606842229170558446836122206078351382968253970864143597110461965175850834817665875538033799957519184628621445302484228100263431427032089411665137733848416897797243448068873485701775788341820346935946117424174847849626391662223056950725043721907635990009814375453736359471825015817067334839806235435545448
y2 = 123161662006626173257658155440995758077644133106347955053437070384032327643606006182254293736352951669348486229126066051376766187014326742185279158572916190461546072737951070108429999738567695487322683707128747508390535278084645507888594491053352777437956961443390580531224529649715922983302553733302183680229442684930688384434263064437787360809879785644243721569717854769078822729636598856450665397631653853730111259561536552440955558062554764155674810156999963831490288009516842695456063350428308329590519170386751067328029955975084626546467505376469180883230078097302660456279461037373526104913049876100168770958
## 上面全部直接照抄 verify.py
## 下面直接照公式來
X = (x1*x2 + k*y1*y2) % n
Y = (x1*y2 - y1*x2) % n

## 底下做個確認
if verify(public, m1*m2,(X,Y)):
	print "x = ",X
	print "y = ",Y

```


## fHash

打開題目頁面
![image](../img/AWIKjad.png)

fHASH 的實作可以看 fHash.py
[second-preimage 的連結](https://en.wikipedia.org/wiki/Preimage_attack)

Pre-image attack(反譯攻擊法)，指由雜湊出的訊息來反推本來的訊息，換句話說是構造出一個指定hash 的訊息，也是這題要考的

先去看 fHash.py ，整個過程是

1. 明文是 8 bytes (hex 後長度: 16) 分四組 0-3,4-7,8-11,12-15
2. 做四次 round ，第一次用第一組明文(0-3) 搭配一開始的 IV(hl, hr)
3. 每次round 做的事情是 hl = foo(hl,m) , hr = foo(hr,m)
4. 他的 foo(a,b) 是將 a+b 做 md5 轉hex 取前 4 byte
5. 最後回傳 hl + hr

我直接用暴力法，先求出第一次 round 後的結果是
```
In [57]: round('7575','7368','A8A8')
Out[57]: ('dcd0', 'a6ea')
```

那我們直接暴力窮舉所有 hl, hr, m ，這邊的 m 只要 2 bytes 即可

```python
import string

allw = string.printable

def do_hr(m):
	for i in allw:
		for j in allw:
			hr = i + j
			hr = hr.encode('hex')
			if foo(hr,m) == 'a6ea':
				print "hr = ",hr
				return 1

for i in allw:
	for j in allw:
		for k in allw:
			for l in allw:
				m = i+j
				m = m.encode('hex')
				hl = k+l
				hl = hl.encode('hex')
				if foo(hl,m) == 'dcd0':
					if do_hr(m) == 1:
						print "hl = ",hl
						print "m = ",m
						raw_input("#")

"""
第一個結果:

hr =  '592a'
hl =  '433c'
m =  '3071'

"""
```

那我們把題目本來的 m 最前面的 2 bytes 換成我們這邊得到得即可

fHash('592a','433c',"3071617269666374") == '260c01da'

## ElGamat
> Description
>
> please read the [PDF](./Challenge.zip).

這題看 pdf 描述是離散對數問題，只不過他的G 是一個矩陣

然後需要找到一個 a ，使得 G^a = H (H 也是矩陣)

而和矩陣扯上邊就跟線性代數有關係，需要線代的一些函數


[參考1](https://github.com/abeaumont/ctfs/tree/master/sharif-2018/el-gamat)
[參考2](https://github.com/philomath213/CTF_WriteUps/tree/master/SharifCTF8/ElGamat)
