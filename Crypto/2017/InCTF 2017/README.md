# InCTF 2017 - Notes

## Multi Layer RSA

e 很大所以直接猜 wiener attack

```
from Crypto.Util.number import *
import owiener

n = 135568509670260054049994954417860747085442883428459182441559553532993752593294067458983143521109377661295622146963670193783017382697726454953197805014428888491744355387957923382241961401063461549210355871385000347645387907568135032087942016502668629010859519249039662555733548461551175133582871220209515648241

c = 0x5d695edb47b81a303d162611f7d407579160ef8818929031e1e13ca20cb7094eddbb0658d95980e1753182c5d5c529fb45062891bb5da573c618e35df0103233ded582a53ed807846b19ea82be427f2bbc63e5c7eb685d8a22b2b7539cf45d4ad93bbf5b892b66288b568b6bbff6bb263d809475e6f0aa3cfd01539d8364c243

e = 1
for i in encryption_keys:
    e *= i

d = owiener.attack(e, n)
m = pow(c, d, n)
print long_to_bytes(m)
```

## RSA 1s fun

看到 n 一樣的廣播會先想到 common modulus attack ，但這題不同的地方在 e 不互質

所以需要開 e 次方根


```python
#!/usr/bin/env python
import libnum
e1 = 9
e2 = 123
c1 = 2866791410300982209581160682590202727064178543076468723716078826950532969157774101954514922479283214185175373229881780072369520438740798302436630031675039672300318769368767955792505592752805860745234692545366181568007521937632340018956679380260500802782833711686141651664082139115158618826168145286856348145354753632046650620308808972739953286345861292290201731165641142066561682325108497439840996007817718867058397591772543642180750091195001088272756689038764789254056479422278248719908521586989566666627884968909640431124163896764204393560913490590077031435330210539197147863375903077038431543732467897239841303254
c2 = 4885380046320959173192546343078276684691332256383912605057298042587886299857925359111993638346079742855901548480637616739859552612594516195353274413384196031117800323365020227270534113077873495873427630043665909900269079429369278616380093363461750865151600963795982366459803668193824090785941635118091474660341873110737939523053889456794499981099067016285308979086542807431649241746997853017895403122499239437959257317791355670927392439947971693686626563871460473615495733407552262810140872942644864039949040024604157449691762976155356244948844966532675041107842219829093528089233085580060616519775692376829287486898
n =20333254691880587307936337314043639948842015851766398721090407302956251747329178671065731363354242526918246592697537469440013326971933436283835869953205389270794974354649936678036319060756577261022556782132429409780897209149764199287410299784057084352324514504271696413494646839995519846723688986124055120364880326007695589111754397828528457250142219463380016968678118831245509936377859985508548247011183090952083546525956426331360929466685835043639197893823027068509935334942858316357902671524385521979877692725137825489358188564620960020623845798362737725511832599703350407211941298094845205725160096135130216181313


s1, s2, mod = libnum.xgcd(e1, e2)

if s1 < 0:
	s1 = s1 * -1
	c1 = libnum.invmod(c1, n)
if s2 < 0:
	s2 = s2 * -1
	c2 = libnum.invmod(c2, n)

m = (pow(c1, s1, n) * pow(c2, s2, n)) % n
m = libnum.nroot(m, mod)
print libnum.n2s(m)
```



